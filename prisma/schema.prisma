generator client {
  provider = "prisma-client-js"
}

// Use DATABASE_URL only (no directUrl). Local: use pooler (port 6543) + ?pgbouncer=true; add ?sslmode=require if connection fails.
// Vercel/production: unchanged â€” use whatever DATABASE_URL you already have. No DIRECT_URL required anywhere.
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum DealType {
  FREE_ITEM
  PERCENT_OFF
  AMOUNT_OFF
  TIME_WINDOW
}

enum OnboardingStatus {
  DRAFT
  SUBMITTED
  APPROVED
  REJECTED
}

enum QRAssetStatus {
  UNREGISTERED
  ACTIVE
  RETIRED
}

enum UserStatus {
  ACTIVE
  DELETED
}

enum VenueStatus {
  ACTIVE
  PAUSED
  DELETED
}

enum NotificationEventStatus {
  PENDING
  SENT
  FAILED
}

enum VenueMemberRole {
  staff
  admin
}

model Venue {
  id                   String           @id @default(cuid())
  name                 String
  address              String?
  neighborhood         String?
  city                 String?
  state                String?
  zipCode              String?
  description          String?
  createdAt            DateTime         @default(now())
  updatedAt            DateTime         @updatedAt
  hourlySeatPrice      Float
  latitude             Float?
  longitude            Float?
  rulesText            String?
  tags                 String[]
  ownerId              String?
  stripeAccountId      String?
  onboardingStatus     OnboardingStatus @default(DRAFT)
  venueTermsAcceptedAt DateTime?
  submittedAt          DateTime?
  approvedAt           DateTime?
  rejectedAt           DateTime?
  rejectionReason      String?
  approvedByUserId     String?
  rejectedByUserId     String?
  status               VenueStatus      @default(ACTIVE)
  pausedAt             DateTime?
  deletedAt            DateTime?
  pauseMessage         String?
  reservations         Reservation[]
  tables               Table[]
  seatBlocks           SeatBlock[]
  deals                Deal[]
  venueHours           VenueHours[]
  favoriteVenues       FavoriteVenue[]
  favoriteTables       FavoriteTable[]
  favoriteSeats        FavoriteSeat[]
  qrAssets             QRAsset[]
  // Hours: canonical source and timezone (see docs/HOURS_AUDIT.md)
  timezone             String?
  hoursSource          String? // "google" | "manual"; null = use google
  hoursUpdatedAt       DateTime?
  // Google Places enrichment fields
  googlePlaceId        String?          @unique
  googleMapsUrl        String?
  openingHoursJson     Json?
  googlePhotoRefs      Json?
  heroImageUrl         String?
  imageUrls            Json?
  owner                User?            @relation(fields: [ownerId], references: [id], onDelete: SetNull)
  approvedBy           User?            @relation("ApprovedVenues", fields: [approvedByUserId], references: [id], onDelete: SetNull)
  rejectedBy           User?            @relation("RejectedVenues", fields: [rejectedByUserId], references: [id], onDelete: SetNull)
  venueMembers         VenueMember[]

  @@index([ownerId])
  @@index([onboardingStatus])
  @@index([status])
  @@index([latitude, longitude])
  @@index([hourlySeatPrice])
  @@index([onboardingStatus, status, pausedAt])
  @@map("venues")
}

model VenueMember {
  id        String          @id @default(cuid())
  venueId   String
  email     String // store lowercased in app
  userId    String?
  role      VenueMemberRole @default(staff)
  createdAt DateTime        @default(now())
  venue     Venue           @relation(fields: [venueId], references: [id], onDelete: Cascade)
  user      User?           @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@unique([venueId, email])
  @@index([venueId, userId])
  @@index([venueId, email])
  @@map("venue_members")
}

model Table {
  id                String          @id @default(cuid())
  venueId           String
  name              String?
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  seatCount         Int             @default(1)
  bookingMode       String          @default("individual") // "group" | "individual"
  tablePricePerHour Float? // For group bookings
  isCommunal        Boolean         @default(false) // For communal spaces like bars
  isActive          Boolean         @default(true)
  imageUrls         Json?
  directionsText    String? // "Directions to your seat"
  reservations      Reservation[]
  seats             Seat[]
  favoriteTables    FavoriteTable[]
  venue             Venue           @relation(fields: [venueId], references: [id], onDelete: Cascade)

  @@map("tables")
}

model Seat {
  id            String         @id @default(cuid())
  tableId       String
  name          String?
  label         String?
  position      Int? // Position within table (1, 2, 3...) for adjacency checking
  pricePerHour  Float
  isActive      Boolean        @default(true)
  tags          Json?
  imageUrls     Json?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  reservations  Reservation[]
  seatBlocks    SeatBlock[]
  favoriteSeats FavoriteSeat[]
  table         Table          @relation(fields: [tableId], references: [id], onDelete: Cascade)

  @@map("seats")
}

model Reservation {
  id                 String           @id @default(cuid())
  venueId            String
  tableId            String?
  seatId             String?
  userId             String?
  status             String           @default("active")
  cancellationReason String?
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt
  endAt              DateTime
  seatCount          Int              @default(1)
  startAt            DateTime
  seat               Seat?            @relation(fields: [seatId], references: [id])
  table              Table?           @relation(fields: [tableId], references: [id])
  venue              Venue            @relation(fields: [venueId], references: [id], onDelete: Cascade)
  user               User?            @relation(fields: [userId], references: [id], onDelete: SetNull)
  dealRedemptions    DealRedemption[]
  payments           Payment[]

  @@map("reservations")
}

model SeatBlock {
  id              String   @id @default(cuid())
  venueId         String
  seatId          String?
  startAt         DateTime
  endAt           DateTime
  reason          String?
  createdAt       DateTime @default(now())
  createdByUserId String?
  venue           Venue    @relation(fields: [venueId], references: [id], onDelete: Cascade)
  seat            Seat?    @relation(fields: [seatId], references: [id], onDelete: Cascade)
  createdBy       User?    @relation(fields: [createdByUserId], references: [id], onDelete: SetNull)

  @@index([venueId, startAt, endAt])
  @@map("seat_blocks")
}

// NextAuth.js required models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model User {
  id                      String           @id @default(cuid())
  name                    String?
  email                   String?          @unique
  emailVerified           DateTime?
  image                   String?
  status                  UserStatus       @default(ACTIVE)
  termsAcceptedAt         DateTime?
  welcomeEmailSentAt      DateTime?
  deletedAt               DateTime?
  deletionReason          String?
  accounts                Account[]
  sessions                Session[]
  reservations            Reservation[]
  venues                  Venue[]
  createdSeatBlocks       SeatBlock[]
  dealRedemptions         DealRedemption[]
  favoriteVenues          FavoriteVenue[]
  favoriteTables          FavoriteTable[]
  favoriteSeats           FavoriteSeat[]
  approvedVenues          Venue[]          @relation("ApprovedVenues")
  rejectedVenues          Venue[]          @relation("RejectedVenues")
  auditLogs               AuditLog[]       @relation("AuditLogActor")
  payments                Payment[]
  refundRequestsRequested RefundRequest[]  @relation("RefundRequestedBy")
  refundRequestsProcessed RefundRequest[]  @relation("RefundProcessedBy")
  venueMemberships        VenueMember[]

  @@index([status])
  @@map("users")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model Deal {
  id              String           @id @default(cuid())
  venueId         String
  isActive        Boolean          @default(true)
  type            DealType
  title           String
  description     String
  featured        Boolean          @default(false)
  eligibilityJson Json?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  venue           Venue            @relation(fields: [venueId], references: [id], onDelete: Cascade)
  redemptions     DealRedemption[]

  @@index([venueId, isActive])
  @@map("deals")
}

model DealRedemption {
  id               String      @id @default(cuid())
  dealId           String
  reservationId    String
  redeemedAt       DateTime    @default(now())
  redeemedByUserId String?
  deal             Deal        @relation(fields: [dealId], references: [id], onDelete: Cascade)
  reservation      Reservation @relation(fields: [reservationId], references: [id], onDelete: Cascade)
  redeemedBy       User?       @relation(fields: [redeemedByUserId], references: [id], onDelete: SetNull)

  @@index([reservationId])
  @@index([dealId])
  @@map("deal_redemptions")
}

model VenueHours {
  id        String   @id @default(cuid())
  venueId   String
  dayOfWeek Int // 0=Sunday, 1=Monday, ..., 6=Saturday
  isClosed  Boolean  @default(false)
  openTime  String? // "HH:MM" format in venue local time, nullable if closed
  closeTime String? // "HH:MM" format in venue local time, nullable if closed
  source    String   @default("google")
  updatedAt DateTime @updatedAt
  venue     Venue    @relation(fields: [venueId], references: [id], onDelete: Cascade)

  @@unique([venueId, dayOfWeek])
  @@index([venueId])
  @@map("venue_hours")
}

model FavoriteVenue {
  id        String   @id @default(cuid())
  userId    String
  venueId   String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  venue     Venue    @relation(fields: [venueId], references: [id], onDelete: Cascade)

  @@unique([userId, venueId])
  @@index([userId])
  @@map("favorite_venues")
}

model FavoriteTable {
  id        String   @id @default(cuid())
  userId    String
  tableId   String
  venueId   String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  table     Table    @relation(fields: [tableId], references: [id], onDelete: Cascade)
  venue     Venue    @relation(fields: [venueId], references: [id], onDelete: Cascade)

  @@unique([userId, tableId])
  @@index([userId])
  @@map("favorite_tables")
}

model FavoriteSeat {
  id        String   @id @default(cuid())
  userId    String
  seatId    String
  venueId   String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  seat      Seat     @relation(fields: [seatId], references: [id], onDelete: Cascade)
  venue     Venue    @relation(fields: [venueId], references: [id], onDelete: Cascade)

  @@unique([userId, seatId])
  @@index([userId])
  @@map("favorite_seats")
}

model QRAsset {
  id               String        @id @default(uuid())
  token            String        @unique
  status           QRAssetStatus @default(UNREGISTERED)
  batchId          String?
  reservedOrderId  String? // Reserved for an order or short-lived allocation claim
  venueId          String?
  resourceType     String? // 'seat' | 'table' | 'area'
  resourceId       String? // Foreign key to seat/table or area identifier
  activatedAt      DateTime?
  activatedBy      String? // User id or email when activated
  activationSource String?       @map("activation_source") // 'venue_print' | 'scan_register' | 'order_fulfillment'
  retiredAt        DateTime?
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
  venue            Venue?        @relation(fields: [venueId], references: [id], onDelete: SetNull)
  qrEvents         QREvent[]

  @@index([venueId])
  @@index([status])
  @@index([batchId])
  @@index([status, reservedOrderId])
  @@map("qr_assets")
}

model QREvent {
  id           String   @id @default(uuid())
  token        String
  qrAssetId    String?
  eventType    String // 'scan' only for now
  venueId      String?
  resourceType String?
  resourceId   String?
  userId       String?
  sessionId    String?
  userAgent    String?
  createdAt    DateTime @default(now())
  qrAsset      QRAsset? @relation(fields: [qrAssetId], references: [id], onDelete: SetNull)

  @@index([token, createdAt])
  @@index([venueId, createdAt])
  @@index([eventType, createdAt])
  @@map("qr_events")
}

model AuditLog {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  actorUserId String?
  action      String
  entityType  String
  entityId    String?
  metadata    Json?
  actor       User?    @relation("AuditLogActor", fields: [actorUserId], references: [id], onDelete: SetNull)

  @@index([actorUserId])
  @@index([entityType, entityId])
  @@index([createdAt])
  @@map("audit_logs")
}

model NotificationEvent {
  id        String                  @id @default(uuid())
  type      String
  status    NotificationEventStatus @default(PENDING)
  dedupeKey String                  @unique
  toEmail   String
  userId    String?
  venueId   String?
  bookingId String?
  payload   Json
  error     String?
  createdAt DateTime                @default(now())
  updatedAt DateTime                @updatedAt
  sentAt    DateTime?

  @@index([status])
  @@index([createdAt])
  @@map("notification_events")
}

enum PaymentStatus {
  PENDING
  PAID
  FAILED
  CANCELED
  REFUNDED
  PARTIALLY_REFUNDED
}

enum RefundStatus {
  REQUESTED
  APPROVED
  DECLINED
  PROCESSING
  SUCCEEDED
  FAILED
}

model Payment {
  id                    String          @id @default(cuid())
  reservationId         String
  userId                String?
  venueId               String
  amount                Int // Amount in cents
  currency              String          @default("usd")
  status                PaymentStatus   @default(PENDING)
  stripePaymentIntentId String?         @unique
  stripeChargeId        String?
  stripeTransferId      String? // For Connect payouts
  metadata              Json?
  createdAt             DateTime        @default(now())
  updatedAt             DateTime        @updatedAt
  paidAt                DateTime?
  failedAt              DateTime?
  reservation           Reservation     @relation(fields: [reservationId], references: [id], onDelete: Cascade)
  user                  User?           @relation(fields: [userId], references: [id], onDelete: SetNull)
  refundRequests        RefundRequest[]

  @@index([reservationId])
  @@index([userId])
  @@index([venueId])
  @@index([status])
  @@index([stripePaymentIntentId])
  @@map("payments")
}

model RefundRequest {
  id                String       @id @default(cuid())
  paymentId         String
  reservationId     String?
  amount            Int // Amount in cents (can be partial)
  currency          String       @default("usd")
  reason            String?
  status            RefundStatus @default(REQUESTED)
  stripeRefundId    String?      @unique
  metadata          Json?
  requestedByUserId String?
  processedByUserId String?
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt
  processedAt       DateTime?
  payment           Payment      @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  requestedBy       User?        @relation("RefundRequestedBy", fields: [requestedByUserId], references: [id], onDelete: SetNull)
  processedBy       User?        @relation("RefundProcessedBy", fields: [processedByUserId], references: [id], onDelete: SetNull)

  @@index([paymentId])
  @@index([reservationId])
  @@index([status])
  @@index([stripeRefundId])
  @@map("refund_requests")
}
